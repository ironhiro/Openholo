#pragma once

#ifndef __ophPAS_h
#define __ophPAS_h

#include "ophGen.h"


#define PI				(3.14159265358979323846f)
#define M2_PI			(PI*2.0)
#define RADIANS			(PI/180.0)			// Angle in radians	
// DEGREE*asin(mytheta)
#define DEGREE2			(180./PI)			// sin(RADIANS*DEGREE*asin(mytheta))

#define NUMTBL			1024
#define NUMTBL2			(NUMTBL-1)
#define MAX_STR_LEN 4000

#define FFT_SEGMENT_SIZE 64

struct VoxelStruct;
struct Segment;

using namespace oph;
/**
* @addtogroup pointcloud
//@{
* @details

* @section Introduction

This module is related methods which generates CGH based on 3D point cloud. It is supported single core
processing, multi-core processing(with OpenMP) and GPGPU parallel processing(with CUDA).

![Fig1.Hologram generation by object beam and reference beam](pics/ophgen/pointcloud/pointcloud_RS_1.png)
-Fig1.Hologram generation by object beam and reference beam

I. Point Cloud Hologram Generation with Rayleigh-Sommerfeld(RS) Integral

Reference wave :
\f[
R
\left(
\xi,\eta
\right)
=
a_{R} \exp
\left\{
-jk
\left(
\xi \sin \theta_{\xi}
+
\eta \sin \theta_{\eta}
\right)
\right\}
\f]


Object wave :

\f[
O
\left(
\xi,\eta
\right)
=
\sum_{p=1}^{N}
\frac{a_{p}}{r_{p}}
\exp
\left\{
j
\left(
kr_{p} + \phi_{p}
\right)
\right\}
\f]


Distance :

\f[
r_{p}
=
\sqrt{
\left(
\xi - x_{p}
\right)^{2}
+
\left(
\eta - y_{p}
\right)^{2}
+
z_{p}^{2}
}
\f]


Intensity :

As shown in Fig. 1, when the object wave and the reference wave are overlapped with each other, an interference pattern is generated by each other. \n
Therefore, the interference pattern of the hologram plate
The intensity, I, is:

\f[
I
\left(
\xi,\eta
\right)
=
\left|
O
\left(
\xi,\eta
\right)
+
R
\left(
\xi,\eta
\right)
\right|^{2}
=
\left|
O
\right|^{2}
+
\left|
R
\right|^{2}
+
R^{*} O + R O^{*}
\f]

Since the \f$\left|O\right|^{2} + \left|R\right|^{2}\f$ in this case does not have three-dimensional information as a DC term, it is not used, and \f$R^{*}O + RO^{*}\f$, which is the following two terms, has hologram information.



\n
The interference pattern generated on the hologram is calculated by the interference between the object wave and the reference wave as in the above equation.\n
Here, the \f$\left|O\right|^{2} + \left|R\right|^{2}\f$ formula is the intensity distribution of the object wave and the reference wave, which is irrelevant to the image of the object, but the \f$R^{*}O + RO^{*}\f$ formula has the hologram information of the object.\n
When calculating the interference pattern, Only a simplified calculation can be performed. If you select this port and calculate it briefly, you will get the following formula.

\f[
I
\left(
\xi,\eta
\right)
=
\sum_{i=1}^{N} \frac{a_{i}}{r_{i}}
\exp
\left(
kr_{i}
+
k \xi \sin \theta_{\xi}
+
k \eta \sin \theta_{\eta}
\right)
\f]

\n
II. Point Cloud Hologram Generation with Rayleigh-Sommerfeld(RS) Integral 2

Rayleigh-Sommerfeld solution I :

\f[
u
\left(
x,y
\right)
=
\frac{z}{j \lambda}
\int_{}^{} {
\int_{\Sigma}^{} {u
\left(
\xi,\eta
\right)
\frac{ \exp
\left(
jkr_{01}
\right)
}
{r_{01}^{2}}
} d \xi
} d \eta
\f]

Impulse response

\f[
h
\left(
x,y
\right)
=
\frac{z}{j \lambda}
\frac{ \exp
\left(
jkr
\right)
}{r^{2}}
\f]


R-S diffraction Anti-alliasing

\f[
\frac{1}{2\pi}
\left|
\frac{\partial \phi}{\partial x}
\right|
<
\frac{1}{2 p_{x}}
,\quad
\frac{1}{2\pi}
\left|
\frac{\partial \phi}{\partial y}
\right|
<
\frac{1}{2 p_{y}}

\qquad \to \qquad

\frac{1}{2\pi}
\left|
\frac{x - x_{o}}{r}
\right|
<
\frac{1}{2 p_{x}}
,\quad
\frac{1}{2\pi}
\left|
\frac{y - y_{o}}{r}
\right|
<
\frac{1}{2 p_{y}}
\f]

\f[
\to	\qquad

\begin{matrix}
x_{o}
-
\left|
\frac{t_{x}}{\sqrt{1 - t_{x}^{2}}}
\sqrt{
\left(
y - y_{o}^{2}
\right)
+
z_{o}^{2}
}
\right|

\quad < \quad
x
\quad < \quad

x_{o}
+
\left|
\frac{t_{x}}{\sqrt{1 - t_{x}^{2}}}
\sqrt{
\left(
y - y_{o}^{2}
\right)
+
z_{o}^{2}
}
\right|
,\\
y_{o}
-
\left|
\frac{t_{y}}{\sqrt{1 - t_{y}^{2}}}
\sqrt{
\left(
x - x_{o}^{2}
\right)
+
z_{o}^{2}
}
\right|

\quad < \quad
y
\quad < \quad

y_{o}
+
\left|
\frac{t_{y}}{\sqrt{1 - t_{y}^{2}}}
\sqrt{
\left(
x - x_{o}^{2}
\right)
+
z_{o}^{2}
}
\right|
\end{matrix}
\f]

\f[
\texttt{where} \quad
t_{x}
=
\frac{\lambda}{2p_{x}}
,\quad
t_{y}
=
\frac{\lambda}{2p_{y}}
\f]


Search Range : Rectangle

\f[
\texttt{x direction}
\quad \to \quad
y
=
y_{o}
\quad \to \quad
x_{o}
-
\left|
\frac{t_{x}}{\sqrt{1 - t_{x}^{2}}} z_{o}
\right|\

<\
x\
<\

x_{o}
+
\left|
\frac{t_{x}}{\sqrt{1 - t_{x}^{2}}} z_{o}
\right|
\f]

\f[
\texttt{y direction}
\quad \to \quad
x
=
x_{o}
\quad \to \quad
y_{o}
-
\left|
\frac{t_{y}}{\sqrt{1 - t_{y}^{2}}} z_{o}
\right|\

<\
y\
<\

y_{o}
+
\left|
\frac{t_{y}}{\sqrt{1 - t_{y}^{2}}} z_{o}
\right|
\f]

\n
III. Point Cloud Hologram Generation with Fresnel Diffraction Integral

Fresnel Diffraction Integral :

\f[
u
\left(
x,y
\right)

=
\frac{z}{j \lambda}
\int_{}^{} {
\int_{}^{} {
u
\left(
\xi,\eta
\right)
\frac{ \exp
\left(
jkr_{01}
\right)
}
{r_{01}^{2}}
} d \xi
} d \eta

\cong
\frac{e^{jkz}}{j \lambda z}
\int_{}^{} {
\int_{}^{} {
u
\left(
\xi,\eta
\right)
\exp
\left\{
j
\frac{k}{2z}
\left[
\left(
x - \xi
\right)^{2}
+
\left(
y - \eta
\right)^{2}
\right]
\right\}
} d \xi
} d \eta
\f]

Impulse response

\f[
h
\left(
x,y
\right)
\cong
\frac{e^{jkz}}{j \lambda z}
\exp
\left\{
j
\frac{k}{2z}
\left(
x^{2}
+
y^{2}
\right)
\right\}
\f]


Fresnel diffraction Anti-alliasing

\f[
\begin{matrix}
\frac{1}{2\pi}
\left|
\frac{\partial \phi}{\partial x}
\right|
<
\frac{1}{2 p_{x}}
,\\
\frac{1}{2\pi}
\left|
\frac{\partial \phi}{\partial y}
\right|
<
\frac{1}{2 p_{y}}
\end{matrix}

\qquad \to \qquad

\begin{matrix}
x_{o}
-
\left|
\frac{\lambda z_{o}}{2 p_{x}}
\right|\

<\
x\
<\

x_{o}
+
\left|
\frac{\lambda z_{o}}{2 p_{x}}
\right|
,\\
y_{o}
-
\left|
\frac{\lambda z_{o}}{2 p_{y}}
\right|\

<\
y\
<\

y_{o}
+
\left|
\frac{\lambda z_{o}}{2 p_{y}}
\right|
\end{matrix}
\f]

*/

/**
* @ingroup PAS
* @brief Openholo PAS based Compter-generated holography.
* @author
*/
class GEN_DLL ophPAS : public ophGen
{
private:
	OphPointCloudConfig pc_config;
	OphPointCloudData pc_data;
	int n_points;
public:
	/**
	* @brief Constructor
	* @details Initialize variables.
	*/
	explicit ophPAS();
protected:
	/**
	* @brief Destructor
	*/
	virtual ~ophPAS();

public:
	

	/**
	* @brief read config files from xml
	* @param[in] fname file name of the xml files
	* @return Type: <B>bool</B>\n
	*				If the function succeeds, the return value is <B>true</B>\n
	*				If the function fails, the return value is <B>false</B>\n
	*/
	bool readConfig(const char* fname);
	/**
	* @brief override
	* @{
	* @brief Import Point Cloud Data Base File : *.ply file.
	* This Function is included memory location of Input Point Clouds.
	*/
	/**
	* @brief override
	* @param[in] _filename PointCloud(*.ply) input file path
	* @return number of Pointcloud (if it failed loading, it returned -1)
	*/
	int loadPoint(const char* _filename);
	
	//int saveAsImg(const char * fname, uint8_t bitsperpixel, void* src, int pic_width, int pic_height);	// 이미지 저장
	int save(const char * fname, uint8_t bitsperpixel, uchar* src, uint px, uint py);
	void save(const char* fname);

	


	//void PASCalcuation(long voxnum, unsigned char *cghfringe, VoxelStruct* h_vox, CGHEnvironmentData* _CGHE);
	void PASCalculation(long voxnum, unsigned char * cghfringe, OphPointCloudData *data, OphPointCloudConfig& conf);
	//void PAS(long voxelnum, struct VoxelStruct *voxel, double *m_pHologram, CGHEnvironmentData* _CGHE);
	void PAS(long voxelnum, OphPointCloudData *data, double *m_pHologram, OphPointCloudConfig& conf);
	void PAS_GPU(long voxelnum, OphPointCloudData *data, double *m_pHologram, OphPointCloudConfig& conf);
	void DataInit(int segsize, int cghwidth, int cghheight, float xiinter, float etainter);
	void DataInit(OphPointCloudConfig& conf);
	void MemoryRelease(void);

	/**
	* @brief Generate a hologram, main funtion.
	* 
	*/
	void generateHologram();
	
	void CalcSpatialFrequency(float cx, float cy, float cz, float amp, int segnumx, int segnumy, int segsize, int hsegsize, float sf_base, float * xc, float * yc, float * sf_cx, float * sf_cy, int * pp_cx, int * pp_cy, int * cf_cx, int * cf_cy, float xiint, float etaint, OphPointCloudConfig& conf);
	
	void CalcCompensatedPhase(float cx, float cy, float cz, float amp, int segnumx, int segnumy, int segsize, int hsegsize, float sf_base, float *xc, float *yc, int *cf_cx, int *cf_cy, float *COStbl, float *SINtbl, float **inRe, float **inIm, OphPointCloudConfig& conf);
	
	void RunFFTW(int segnumx, int segnumy, int segsize, int hsegsize, float **inRe, float **inIm, fftw_complex *in, fftw_complex *out, fftw_plan *plan, double *pHologram, OphPointCloudConfig& conf);

	/**
	* @brief encode Single-side band
	* @param Vector band limit
	* @param Vector specturm shift
	*/
	void encodeHologram(const vec2 band_limit, const vec2 spectrum_shift);
	void encoding(unsigned int ENCODE_FLAG);
	

	double *m_pHologram;

	float m_COStbl[NUMTBL];
	float m_SINtbl[NUMTBL];

	int m_segSize;
	int m_hsegSize;
	int m_dsegSize;
	int m_segNumx;
	int m_segNumy;
	int m_hsegNumx;
	int m_hsegNumy;

	float* m_inRe_h;
	float* m_inIm_h;

	float	*m_SFrequency_cx;
	float	*m_SFrequency_cy;
	int		*m_PickPoint_cx;
	int		*m_PickPoint_cy;
	int		*m_Coefficient_cx;
	int		*m_Coefficient_cy;
	float	*m_xc;
	float	*m_yc;
	unsigned char* cgh_fringe;

	float	m_sf_base;

	fftw_complex *m_in, *m_out;
	fftw_plan m_plan;

	float	**m_inRe;
	float	**m_inIm;

	float	m_cx;
	float	m_cy;
	float	m_cz;
	float	m_amp;
};

struct GEN_DLL VoxelStruct							// voxel structure - data
{
	int num;								// voxel or point number
	float x;								// x axis coordinate
	float y;								// y axis coordinate
	float z;								// z axis coordinate
	float ph;								// phase
	float r;								// amplitude in red channel
	float g;								// amplitude in green channel
	float b;								// amplitude in blue channel
};


struct GEN_DLL Segment
{
	bool	WorkingFlag;
	long	SegmentIndex;
	int		SegSize_x;
	int		SegSize_y;
	int 	hSegSize_x;		// Half size
	int 	hSegSize_y;		// Half size
	double	CenterX;
	double	CenterY;
	double	FrequencySlope;
};
#endif // !__ophPAS_h